# Decorating the North Pole in Hardcaml

[![AoF 2025 - Puzzle Tests](https://github.com/kagandikmen/aof-2025-temp/actions/workflows/run_tests.yaml/badge.svg)](https://github.com/kagandikmen/aof-2025-temp/actions/workflows/run_tests.yaml)

This repository contains my solutions to the [Advent of FPGA 2025](https://blog.janestreet.com/advent-of-fpga-challenge-2025/) challenge from Jane Street. It implements the solutions in Hardcaml, which is an "embedded hardware design domain specific language (DSL) implemented in OCaml" [[1]](https://arxiv.org/abs/2312.15035).

This repository is a fork of the [Hardcaml Arty](https://github.com/fyquah/hardcaml_arty) project, which is a Hardcaml library to interface with Arty A7 boards.

## Advent Calendar (aka Project Progress)

█████████████████████░░░░░░░░░░░░░░░&nbsp;&nbsp;&nbsp;58.3%

0️⃣1️⃣ ✅ &nbsp;&nbsp;&nbsp; 0️⃣2️⃣ ✅ &nbsp;&nbsp;&nbsp; 0️⃣3️⃣ ✅ &nbsp;&nbsp;&nbsp; 0️⃣4️⃣ ✅  
0️⃣5️⃣ ✅ &nbsp;&nbsp;&nbsp; 0️⃣6️⃣ ✅ &nbsp;&nbsp;&nbsp; 0️⃣7️⃣ ✅ &nbsp;&nbsp;&nbsp; 0️⃣8️⃣ ⬜  
0️⃣9️⃣ ⬜ &nbsp;&nbsp;&nbsp; 1️⃣0️⃣ ⬜ &nbsp;&nbsp;&nbsp; 1️⃣1️⃣ ⬜ &nbsp;&nbsp;&nbsp; 1️⃣2️⃣ ⬜ 

## Project Structure

```text
lib
├── hardcaml_aof        # Advent of FPGA solution library
├── hardcaml_aof_test   # Advent of FPGA testbench library
└── hardcaml_arty       # Hardcaml Arty (for Arty A7 w/ Hardcaml)
src
└── dayXX
    └── dayXX.ml        # Solution for the puzzle of day XX
test
└── dayXX
    ├── input.txt       # Puzzle input of the day
    ├── ref.py          # Reference solution in Python
    └── test_dayXX.ml   # Testbench for the solution of the day
```

## Getting Started

To run the tests, you must have OCaml and opam on your machine. Refer to [OCaml's official installation guide](https://ocaml.org/docs/installing-ocaml) to install them.

After the installation, run:

```bash
opam init
opam switch create hardcaml 4.13.1
opam switch hardcaml
eval $(opam env)
opam repo add janestreet-bleeding https://ocaml.janestreet.com/opam-repository
opam repo add janestreet-bleeding-external https://github.com/janestreet/opam-repository.git#external-packages
opam install ocaml-lsp-server odoc ocamlformat utop
opam install hardcaml hardcaml_waveterm ppx_jane ppx_expect ppx_deriving_hardcaml
```

This will create an opam switch `hardcaml` in version 4.13.1, switch to it, and install required dependencies.

## Running the Tests

Given you have all prerequisites in place, run:

```bash
dune runtest
```
from the project root to run all the tests at once. You can also use:

```bash
dune runtest test/dayXX test/dayXY
```
to specify which tests you want to run. For the waveform files generated by the testbenches, navigate to the `/tmp/` directory on your machine.

**IMPORTANT:**

I used OCaml Base Compiler 4.13.1 working through the puzzles. You may observe peculiarities if you use a different version. (The compiler complaining because `of_int` is used instead of `of_int_trunc` is a strong sign thereof, for example.). Please check you are on the right version by using:

```bash
opam switch show
```

<details>
<summary>Are you on a different version?</summary><br>

If you are using a different version of OCaml, run:

```bash
opam switch create hardcaml 4.13.1
opam switch hardcaml
eval $(opam env)
```

to create a new opam switch with the right version, and switch to it. You can also refer to the [Github Actions workflow configuration](.github/workflows/run_tests.yaml) of this repository for the exact specifics of the intented setup.

</details>

## Solution Details

<details>
<summary><b>Day 1:</b> Secret Entrance</summary><br>

<h2>Day 1: Secret Entrance</h2>

### Summary

The puzzle of day 1 consists of two steps. For a given turning sequence, it needs to be computed:

- how many times the lock mechanism of a door stops at zero (Step 1)
- how many times the lock mechanism of a door hits zero (Step 2)

### My Solution

[My solution](src/day01/day01.ml) takes a structured performance-first approach while avoiding the use of area- and power-hungry multiplication or division logic. The rotation values are first converted to 16-bit integers by the host, the sign of the integer depending on the direction of the rotation. These integers are then sent to the FPGA sequentially over UART. After each integer arrives, the FPGA computes:

- whether the lock stops at zero (for step 1)
- whether the lock hits zero (for step 2)

These computations are performed while the next integer is still being transmitted over UART. This allows for an efficient "pipelined" execution that overlaps communication and computation.

For each rotation, the logic computes the quotient and remainder of a division by 100 using iterative subtraction, taking advantage of the rotation values never exceeding 1000 in this case. The iteration count (defaulted to nine) can easily be increased or decreased for different rotation sequences. How the performance vs. area tradeoff would be affected by the usage of division operation may be inquired in the future.

<br><br><br></details>

<details>
<summary><b>Day 2:</b> Gift Shop</summary><br>

<h2>Day 2: Gift Shop</h2>

### Summary

The puzzle of day 2 also consists of two steps. For any given range, the hardware needs to compute how many integers are in the range with a digit sequence

- that is a subsequence repeating itself twice (Step 1)
- that is a subsequence repeating itself **at least** twice (Step 2)

For further reference, I called the integers that fulfill these criteria "silly numbers" and "goofy numbers", respectively. Don't ask why :D Note that silly numbers are always a subset of goofy numbers.

### My Solution

In [my solution](src/day02/day02.ml), the range bounds are first converted into 40-bit integers. The host (testbench) then sends all values in the range sequentially through UART. After arriving at the FPGA, the values are then converted into binary-coded decimal (BCD) format to enable digit processing. The function that does the conversion takes advantage of the fact that the biggest range value has 10 digits, but this is easily configurable in the source code. The logic then computes how many leading zeros the number has. After that, it is computed whether the number is silly and/or goofy. Finally, the number is added to a running total or dismissed.

### Suggestions

Instead of sending all values in the range one after another, an implementation that can iterate in the hardware would be more efficient. For this,

- an FSM
- logic to increment BCD

need to be added to the implementation.

<br><br><br></details>

<details>
<summary><b>Day 3:</b> Lobby</summary><br>

<h2>Day 3: Lobby</h2>

### Summary

The puzzle of day 3 also consists of two steps. For any given digit sequence, the puzzle requires us to compute what is the highest achievable value after deleting a given number of digits. In the first step, 2 digits are left; in the second step, 12 are left.

### My Solution

In [my solution](src/day03/day03.ml), the sequence for each bank is transmitted to the FPGA digit by digit via UART, starting from the most significant digit. The digits are not converted to integers this time, they are sent as 8-bit ASCII characters. In this puzzle, each sequence has exactly 100 digits. This means we are allowed to drop 98 of them for the first step. 88 of them for the second step, likewise. For any given number of digits to pick, k, the FPGA first computes how many digits can be dropped per bank, 100 - k. Then it processes every arriving digit immediately by comparing it to the already-picked values. Given there are still enough remaining "drop credits" at the time of arrival, the previously-picked digits are dropped if they are smaller than the incoming one. Finally, once all 100 digits are processed, the remaining digits are converted to decimal and added to a running total.

### Suggestions

My implementation hardcodes the bank width 100 to the logic. Although this is easily changeable in the source code, one may want a design capable to adjust itself for different sequence widths. I can think of two ways:

- **Accepting the whole sequence, and then starting the computation:** In such an implementation all digits of the sequence would first be transmitted and saved by the FPGA. Once the FPGA is "notified" that the transmission is completed, it would start to iterate over the digits from the most significant to the least significant.
- **Sending the sequence width beforehand:** In such an implementation the host would first send the width of the sequence and then start sending the digits one by one. The digits would still all be processed immediately on arrival.

I personally like the second much more. The first one asks for a lot more memory, and requires back-and-forth communication between the host and the FPGA. Not to mention one will have to set a maximum sequence width anyways, as the number of registers is fixed at design time. The second one handles the problem with much less memory overhead, and it does not require the host to wait for a done signal from the FPGA either.

<br><br><br></details>

<details>
<summary><b>Day 4:</b> Printing Department</summary><br>

<h2>Day 4: Printing Department</h2>

### Summary

The puzzle of day 4 requires us to solve a k-core peeling algorithm; 4-core in this case. The first step asks for how many vertices are removed in the first iteration, whereas the second step asks for how many are removed for an iteration count approaching infinity.

### My Solution

[My solution](src/day04/day04.ml) implements an iterative, multi-pass, memory-resident algorithm with the following finite state machine:

- **LOAD**: In this state, all field info is transmitted to the FPGA via UART. The dots and ats are transmitted in ASCII format without any host processing. The FPGA receives and stores them one by one into a 140x140 grid. Each cell of the grid has the following contents:

```ocaml
module Cell = struct
  type 'a t =
  {
    is_roll: 'a;
    is_accessible: 'a;
  }

  ...
end
```

Both `is_roll` and `is_accessible` are 1-bit wide. The state LOAD only writes `is_roll` though, `is_accessible` is computed in the state MARK. After the loading of all fields is complete, the FSM continues with the state MARK.

- **MARK**: This state iterates over all cells, computes their accessibility, and sets their `is_accessible` field accordingly. An accessible cell is a cell that has less than 4 neighbors occupied by paper rolls. Once all cells are iterated, the FSM continues onto the state REMOVE.
- **REMOVE**: This state iterates over all cells once again, and sets their `is_roll` field zero if they are both occupied by a roll and set accessible by the MARK state. (This is essentially "removing the paper roll.") Once the iteration is done, the logic checks if `max_passes` number of MARK-REMOVE iterations is achieved. If yes, then the FSM moves onto DONE. If not, then it returns back to MARK for another iteration. For the case where `max_passes` is set to zero, the MARK-REMOVE loop continues forever until there are no more rolls to remove. The number of removed rolls is accumulated in the register `total_removed`.
- **DONE**: This is the state the logic arrives at after breaking from the MARK-REMOVE loop. The FPGA signals back to the host that the computation is done, so the host knows that `total_removed` is stabilized.

`max_passes` is not a compile-time constant. It is implemented as an input signal to the FPGA. I presume it would be fairly easy to make it a compile-time constant, though.

The grid dimensions are a compile-time constant. That each cell is implemented as a 2-bit field helps minimize the memory footprint.

### Suggestions

The algorithm in itself is unfortunately not very hardware-friendly. The 140x140 grid is therefore a necessity rather than a design choice. To improve performance, another algorithm could be implemented to keep track of the roll removals of the previous row. This would enable the two states MARK and REMOVE to be merged together, resulting in sizeable performance boost.

<br><br><br></details>

<details>
<summary><b>Day 5:</b> Cafeteria</summary><br>

<h2>Day 5: Cafeteria</h2>

### Summary

Like the others, the puzzle for day 5 consists of two steps. It is based on a text input that consists of lines that are either integers (IDs) or integer ranges. In the first step, it is computed how many of the IDs fall on at least one of the ranges. In the second step, it is computed how many integers in general fall on at least one of the ranges. The main challenge, especially in step two, is that the ranges both overlap and come unsorted.

### My Solution

[My solution](src/day05/day05.ml) implements a data structure called "Package" to standardize sending of ranges, ingredient IDs, and other sorts of control signals. Every package consists of an 8-bit flag and 64-bit payload. The 8-bit flag:

- `0x01` signals that the payload is the lower bound of a new range,
- `0x02` signals that the payload is the upper bound of the range the lower bound of which was just sent,
- `0x03` signals "section change," which means that all ranges are done being sent and ingredient IDs will follow,
- `0x04` signals that the payload is an ingredient ID,
- `0xFF` signals EOF.

Other 8-bit values are invalid as flags. My solution then implements the following state machine:

```ocaml
module States = struct
  type t =
    | Read_ranges
    | Read_ids
    | Scan
    | Merge
    | Count
    | Done
  [@@deriving sexp_of, compare, enumerate]
end
```

The FPGA, starting in the state `Read_ranges`, first reads all the ranges in the order they are fed to the UART bus by the host. The moment the host signals a section change, the logic transfers to the state `Read_ids`. When the host is done with sending all IDs, it signals EOF, and the logic starts sorting the ranges. The sorting process (selection sort) starts with the state `Scan`. In this state, the FPGA looks for the range with the lowest lower bound that is not marked as "used" yet. Then it moves onto the state `Merge`, which is where we scan through all unused ranges once again for candidates eligible for a range merge. Then, if there are still unused ranges left, the FPGA goes back to the state `Scan`. Once the `Scan`-`Merge` loop is completed, the logic goes into the `Count` state. In this state, we count how many of the IDs fall in any one of the merged ranges. Finally, the FPGA arrives at the state `Done`, where it signals back to the host that the computation is successfully completed.

### Suggestions

I don't know how it could be done, but a better sorting & merging algorithm would be much appreciated. Sorting is not particularly hardware-friendly. Selection sort, the sorting algorithm I implemented, has a time complexity of O(n^2). If there is any possibility to sort the ranges before feeding them into the FPGA, this would prevent a lot of computation & logic complexity from happening in the first place.

Another suggestion could be made about the packaging, in case we are on a quest to save every single cycle possible. The section change and EOF signals do not send any meaningful payload, but the FPGA waits for this payload to be fully sent before going forward with the signaled operation. In current implementation, the host fills the payload field with zeros. This is not even remotely the performance bottleneck of the application, but fixing it would save a couple cycles.

<br><br><br></details>

<details>
<summary><b>Day 6:</b> Trash Compactor</summary><br>

<h2>Day 6: Trash Compactor</h2>

### Summary

Like the others, the puzzle for day 6 consists of two parts. It is based on a text input that consists of a matrix of integers, followed by a final row of operation signs. (Either addition or multiplication in this case.) The integers (and the operator) that are found in the same column belong to each other and constitute an operation. (I called this union of integers and operator an "opblock.") In part 1, the integers are to be parsed left to right, whereas in part 2 they are parsed from top to bottom.

### My Solution

[My solution](src/day06/day06_new.ml) starts its life in `Idle` state and immediately starts listening to the UART bus. When the host sends the ASCII value for "start of text," the FPGA transfers into the state `Receive`. In this state, the FPGA saves the characters of the incoming text (with zero preprocessing this time) one by one in its RAM.

When the host transfers the ASCII value "end of text," the FPGA moves onto the state `Find_opblk_start`. Then moving further onto the state `Find_opblk_end`, the FPGA iterates over all columns to figure out at which column the next opblock starts and ends. (Bear in mind our columns are one character wide.) Once the borders are figured out, the FPGA continues with the states `Setup_compute` and `Compute`, the latter of which activates the "secondary state machines." These secondary state machines are another type of state machine, which we instantiate twice. They work simultaneously; and they only differ in the specifics of the computation one of their states includes. The first state machine is for part 1, and the second is for part 2. So, for each opblock, the parts 1 and 2 are computed in parallel, saving latency.

When both secondary state machines arrive at their `Done` state and return, the primary state machine adds the return values into a running total and continues with the next iteration of the loop: `Find_opblk_start`-`Find_opblk_end`-`Setup_compute`-`Compute`. After all opblocks are processed this way, the running totals are returned to the host.

There was an [older solution](src/day06/day06_old.ml) for this puzzle where the characters were saved in an array called `grid` instead of a RAM. As it takes linear time to index, read, or write to arrays, this older implementation was embarrassingly slow. The random access into the "character memory" as offered by the newer RAM-based implementation is incomparably faster. With the full puzzle input, the newer solution takes ~4 minutes to simulate on my machine. The older solution was still going strong when I terminated it after an hour.

### Suggestions

I feel like the main state machine could be made more compact by removing the state `Setup_compute`. I am planning to revisit this puzzle to see if the compute setup can be moved to the `Find_opblk_end` and/or `Compute` states.

Another idea would be to implement "opblock engines" for each opblock received/saved. Iterating over the rows (either during transmission or after it,) each value on the row would be sent to its dedicated opblock engine, which would both add and multiply all the operands as they come. Once the final row arrives with the correct operation, the opblock engine would then already have the result and return it immediately. 

The biggest performance bottleneck of the new version of the application is the UART transmission, which consumes around 95% of the cycles. I intend to keep the UART bus for seamless FPGA deployment in the future. In case your situation allows you to opt for a parallel (or simply faster) protocol, this opblock engines idea would be worth considering.

But all this under a condition: As the relation "columns per row" grows, this idea of parallel processing could prove impractical due to power and/or area concerns.

<br><br><br></details>

<details>
<summary><b>Day 7:</b> Laboratories</summary><br>

<h2>Day 7: Laboratories</h2>

### Summary

The part 1 of the seventh puzzle requires us to find how many times a beam split event happens in a given positioning of beam inputs and splitters. The second part requires the computation of how many alternative paths there are for a beam to follow from the beginning (top) until the end (bottom).

### My Solution

In [my solution](src/day07/day07.ml), the input text is first sent through the UART bus to the FPGA without any preprocessing. The beginning of the transmission triggers the `Idle` -> `Receive` state transition on the FPGA side, whereas the end of transmission triggers `Receive` -> `Compute`. The characters, which were saved into a 256x256 RAM in `Receive` state, are iterated over during `Compute`. At each row, the logic compares the current row with the row before, and saves both 

- number of split events in that row
- how many alternative ways there are for the beam to access each field of the current row.

At the end of each row, the logic transfers to the state `Switch_rows` and then goes back to the state `Compute` for the next row. Once the `Compute`-`Switch_rows` loop is completed for every row, the FPGA concludes the computation with the states `Conclude` and `Done`, respectively. Just as usual, a done signal is raised at the end to notify the host.

### Suggestions

This puzzle is actually very suitable for parallel processing of the characters in a row. The moment all characters are successfully transmitted and saved, the control logic could iterate over the rows from top to bottom, and feed all the characters one-by-one to an array of "column engines." Each column engine would have a small memory keeping track of 

- current presence of beam
- number of alternative paths to arrive at that column for the current row index.

However, judging by the waveform I can say that more than 95% of the cycles are spent during the UART transmission. So the row-wise + column-wise iteration is not the performance bottleneck of the application. I intend to keep the UART transmission for the sake of seamless future FPGA deployment, but in case you are fine with replacing it with some parallel/faster transmission method, this "column engines idea" could prove beneficial for you.

<br><br><br></details>

## License

This project is licensed under the MIT License. See [LICENSE](LICENSE) for details.
